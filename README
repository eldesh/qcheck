QCheck/SML
==========

This is QCheck/SML, modeled after the QuickCheck automatic testing
library for Haskell by Koen Claessen and John Hughes [ICFP 2000,
Haskell 2002] (with many thanks).  Nearly all of the concepts come
directly from their ICFP paper, but the implementation is of course
quite different.  Like its cousin, QCheck supports random generation
of test data, but doesn't emphasize that source over any other:
indeed, the checker is polymorphic over the type of test-case streams.

QCheck was developed for SML/NJ 110.45, and it uses parts of the
SML/NJ library.  It should, however, be possible to adapt it to other
SML implementations (including older versions of NJ).  I am open to
suggestions that would improve its portability or usability.

The latest version of QCheck may be downloaded from 
http://contrapunctus.net/dist/qcheck/

This library is free software; you may redistribute and/or modify it
under the terms of the GNU Lesser General Public License (LGPL) as
published by the Free Software Foundation; see the file COPYING.

Copyright (c)2004 Christopher League <league@contrapunctus.net>

Introduction
------------

I will demonstrate the use of QCheck with a simple example.  Let's
write a few tiny functions on integers: successor, even, and odd.

     fun succ x = x+1
     fun even x = x mod 2 = 0
     fun odd x = x mod 2 = 1

Now suppose we wish to test that some property holds for this
implementation.  For example, we know that the successor of an even
number should be odd.  We can specify "the successor is odd" as the
integer predicate "odd o succ".  But since we expect this to be true
only for even numbers, it is a conditional property.  Using the
QCheck library, we specify it like this:

     open QCheck infix ==>
     val succ_even_odd = even ==> odd o succ

This value has type "int prop".  To test it, we need to specify a
source of integer test cases.  We could type a bunch of them into a
file and use that, but why not just generate them randomly?
"Gen.Int.int" (of type "int Gen.gen") generates random integers.  The
following pair is useful for checking any integer property:

     val i = (Gen.Int.int, SOME Int.toString)
     checkGen i ("even+1=odd", succ_even_odd)

The "toString" function is provided so that the checker can print out
a counter-example if necessary.  Next, we simply called "checkGen"
with a string tag and the property.  The type of "checkGen" is

     checkGen : 'a Gen.gen * ('a -> string) option
                 -> string * 'a prop -> unit

"checkGen" is a specialization of a slightly more general "check"
routine, specifically tailored for randomized data sources.  The
output of calling "checkGen" above is:

     even+1=odd.............ok      (100 passed)        
     val it = () : unit

This indicates that 100 test cases were considered, and all passed.
(The target number of randomly-generated test cases is configurable,
as we'll see later.)  Now, let's try the converse property: the
successor of an odd number is even.

     val succ_odd_even = odd ==> even o succ
     checkGen i ("odd+1=even", succ_odd_even)

Simple, right?  Well, this time we run into trouble.  Here is the
output:

     odd+1=even.............FAILED  (99/100 passed)     
           counter-examples:       1073741823

QCheck found a counter-example: the maximum 31-bit integer.  It is
odd, but since its successor is undefined, the property does not hold.
(We were not extraordinarily lucky to generate maxInt this time
around; in fact, the generator is biased so that zero, minInt, and
maxInt are chosen more frequently than other integers, precisely
because they are often "boundary conditions.")

At any rate, what is broken here is not really our even/odd/succ
implementation, but rather the specification of the property.  We need
to limit it to odd integers that are less than maxInt.

     fun odd_not_max x = odd x andalso x < valOf(Int.maxInt)
     val succ_odd_even = odd_not_max ==> even o succ
     checkGen i ("odd+1=even", succ_odd_even)

     odd+1=even.............ok      (100 passed)        

Incidentally, the 100 cases to which this output refers are all
integers that meet the odd_not_max criterion.  Generated integers that
do not meet the criterion are not counted.  This is the meaning of the
==> (implies) operator, and is the reason that we don't just combine
the condition with the predicate into one function.

Continuing with this example, suppose we want to test a property of a
pair of integers.  For example, the sum of two odd numbers is even.

     fun both_odd(x,y) = odd x andalso odd y
     fun sum_even(x,y) = even (x+y)
     fun show_pair(x,y) = Int.toString x ^ "," ^ Int.toString y

To generate pairs of ints, we just zip together two integer
generators.  The function "Gen.zip" takes a t1 generator and a t2
generator, and produces an (t1 * t2) generator.

     checkGen (Gen.zip(Gen.Int.int, Gen.Int.int), SOME show_pair)
              ("sum_odds_even", both_odd ==> sum_even)

     sum_odds_even..........FAILED  (97/100 passed)     
           counter-examples:       897083003,850430501
                                   1073741823,298807
                                   ~845110003,~715751599

As you can see, QCheck found a few counter-examples (including
negative integers) that overflow the sum computation.  I'll leave it
as an exercise to the reader to fix this.

One more example will demonstrate that test cases need not be
generated randomly.  Here, they will be taken from a list, but they
could just as easily be read from a file.

     check (List.getItem, SOME show_pair)
           ("sum_odds_even[]", both_odd ==> sum_even)
           [(1,1), (3,5), (3,4), (* that one won't count! *)
            (~1,1), (21,21), (7,13)]

     sum_odds_even[]........ok      (5 passed)          

I provided 6 pairs in the list, but only 5 counted because (3,4) did
not meet the precondition of the property.


Reading test cases from the file system
---------------------------------------

     Once a human tester finds a bug, it should be the last time
     a human tester finds that bug. Automatic tests should check
     for it from then on.        -- Andrew Hunt and David Thomas
                                        The Pragmatic Programmer

Random testing is neat, and sometimes uncovers interesting cases that
you may not have tried.  But to be sure you are covering specific
cases, you need to specify them somehow.  The list example at the end
of the last section is one way, but another is reading them from a
file.  QCheck provides a small API for using files within a directory
or lines within a text file as test cases.

The first parameter to "check" is a polymorphic "reader"

     type ('a,'b) reader = 
           'b -> ('a * 'b) option

where 'b is the type of a stream, and 'a is the type of a test case.
The "FileSys" structure provides readers and utilities for directories
and files:

     type dirstream
     val openDir : string -> dirstream
     val nextFile : (string, dirstream) reader

     type filestream
     val openFile : string -> filestream
     val nextLine : (string, filestream) reader

     val map : ('a -> 'b) -> ('a,'c) reader -> ('b,'c) reader
     val filter : ('a -> bool) -> ('a,'b) reader -> ('a,'b) reader
     val match : string -> (string,'a) reader -> (string,'a) reader
     val chop : (string,'a) reader -> (string,'a) reader

The "match" function filters out filenames (or lines) that match a
particular regular expression.  The "chop" function removes the
newline (if present) from each line.

When writing a compiler, you may want to test that the parser accepts
a certain set of programs and rejects another set.  Assuming
"parseFile" takes a string (the filename) and returns a boolean, this
is all you need:

     check (FileSys.match "\\.sml" FileSys.nextFile,
            SOME(fn s => s))
           ("accept", pred parseFile)
           (FileSys.openDir "tests/good")

and similarly for the directory "tests/bad", but with the predicate
(not o parseFile).  The show function is identity, since the test
cases are already strings (representing filenames).


Generating test cases randomly
------------------------------

The QuickCheck tool for Haskell uses type classes so that arbitrary
values of various types may be generated behind the scenes.  In SML,
we need to be more explicit, but the same holds true in Haskell if we
don't want the default generator (positive integers only, for
example).

The "Gen" module holds a wide range of tools for creating random
values of various structured types and, yes, even functions!  We have
already met "Gen.zip", but some of the other basic combinators are:

     val range : int * int -> int gen  (* between x and y, inclusive *)
     val lift : 'a -> 'a gen
     val select : 'a vector -> 'a gen
     val choose : 'a gen vector -> 'a gen
     val filter : ('a -> bool) -> 'a gen -> 'a gen
     val map : ('a -> 'b) -> 'a gen -> 'b gen

So, (lift 5) is a "generator" that always returns 5 - no randomness
involved.  "choose" selects and invokes one of the generators in its
argument vector (with equal probability), so

     Gen.choose #[Gen.lift 42,
                  Gen.Int.int]

will return the number 42 with 50% probability, and a random integer
otherwise (but recall that Gen.Int.int is biased toward zero and the
extrema).  "select" is like "choose" combined with "lift".  Other
combinators exist for generating lists, vectors, and option types.
For example, the following generates a string with between 6 and 10
characters from the alphabet {a,b,c}:

     Gen.vector CharVector.tabulate
                (Gen.range(6,10), Gen.select #[#"a", #"b", #"c"])

where

     Gen.vector : (int * (int -> 'a) -> 'b) ->
                  int gen * 'a gen -> 'b gen

works on any data structure with a "tabulate" constructor.

Here is a sample of some of the strings it generated in one test:
 
     "abbacccbbb" : CharVector.vector
     "bccbaabacb" : CharVector.vector
     "aacbbbaba" : CharVector.vector
     "aabbaca" : CharVector.vector
     "acaacbb" : CharVector.vector
     "cbbbccab" : CharVector.vector
     "bbcaccca" : CharVector.vector

In addition to the general combinators, practically all of the SML
Basis types have associated generators in sub-structures.  We've
already met Gen.Int.int, but there is also:

     Gen.Int.int : int gen
     Gen.Int.pos : int gen     (* strictly positive *)
     Gen.Int.neg : int gen
     Gen.Int.nonpos : int gen
     Gen.Int.nonneg : int gen  (* zero or positive *)

And similarly for the other integer types:

     Gen.Int32.int : Int32.int gen
     Gen.IntInf.int : IntInf.int gen

And many others:

     Gen.Word.word : word gen
     Gen.Word8.word : Word8.word gen
     Gen.Word32.word : Word32.word gen
     Gen.Real.real : real gen
     Gen.DateTime.weekday : Date.weekday gen
     Gen.DateTime.dateFromYear : int gen -> Date.date gen

Finally, the Text types - character, string, and substring:

     Gen.char : char gen
     Gen.charRange : char * char -> char gen
     Gen.charFrom : string -> char gen
     Gen.charByType : (char -> bool) -> char gen
     Gen.string : (int gen * char gen) -> string gen
     Gen.substring : string gen -> substring gen

So the "Gen.vector" example above could be written more concisely as:

     Gen.string (Gen.range(6,10), 
                 Gen.charFrom "abc")

Finally, all of the generators for basis types are implemented as
functors, so it would be trivial to produce generators for Word16,
Int64, or WideText, given an implementation of those structures.
Browse the file "gen/gen.sig" in the distribution to discover more of
the available generator functionality.

As pointed out in the QuickCheck paper, one needs to be careful when
generating tree-structured data, due to the strong possibility of
non-termination.  To avoid this problem, make the generator a function
of a decreasing integer parameter.  When that parameter reaches zero,
the only choice is to return a leaf.

     datatype tree = Node of tree * tree | Leaf of int
     fun gentree 0 = Gen.map Leaf Gen.Int.int
       | gentree n = 
         Gen.choose' #[(1,Gen.map Leaf Gen.Int.int),
                       (4,Gen.map Node (Gen.zip(gentree(n div 2),
                                                gentree(n div 2))))]

Statistical distribution
------------------------

One problem with random test-case generation is thet we don't know for
sure what we're getting.  QCheck provides a way to observe the
distribution of test cases by tagging them based on user-definable
criteria.  For example, suppose we want to test the "ListMergeSort"
module in the SML/NJ library, by generating random integer lists.

If we generate and pass 100 cases, what does that mean?  Sorting a
list with fewer than 2 elements is pretty easy, so how many of our 100
cases are that trivial?  Also, how many of the lists are already
ordered?

     fun fewer_than n L = length L < n

     val sort_ok = ListMergeSort.sorted op> o
                   ListMergeSort.sort op>

     val sort_test = trivial (fewer_than 2)
                    (classify (ListMergeSort.sorted op>) "pre-sorted"
                    (pred sort_ok))

     checkGen (Gen.list (Gen.flip'(1,9)) Gen.Int.int, NONE)
              ("ListMergeSort", sort_test)

Now the test result, if passing, will be accompanied with some
statistics on the distribution of the specified properties.

     ListMergeSort..........ok      (100 passed)         33% pre-sorted
                                                         28% trivial

The functions "classify" and "trivial" are specializations of the more
general "classify'" (prime), with which we can provide a function that
returns the tag.  To see the complete distribution of list lengths,
try this:

     fun sizeTag n = 
         "length "^ StringCvt.padLeft #" " 3 (Int.toString n)

     val sort_test = classify' (SOME o sizeTag o length) (pred sort_ok)
     checkGen (Gen.list (Gen.flip'(1,9)) Gen.Int.int, NONE)
              ("ListMergeSort", sort_test)


     ListMergeSort..........ok      (100 passed)         13% length   0
                                                          7% length   1
                                                          6% length   2
                                                         13% length   3
                                                          8% length   4
                                                          6% length   5
                                                          3% length   6
                                                          2% length   7
                                                          5% length   8
                                                          5% length   9
                                                          2% length  10
                                                          5% length  11
                                                          3% length  12

The list goes on: the maximum length list generated in this run was
43.  The signatures of these and other property combinators are in
qcheck.sig.


Pluggable output styles
-----------------------

The default output style is modeled after the unit-testing framework
for Perl.  It makes room for statistics and counter-examples, while
leaving clear a column down the middle where the "ok/FAILED" results
can be easily read.  The Perl style uses the carriage return character
\r to update the current line with each test... this is a useful
progress indicator for tests that take a long time.

Output styles are completely configurable just by writing a function
of a particular type.  An alternate style is provided, which is meant
to mesh well with the output of the SML/NJ Compilation Manager (CM),
like this:

     [testing Bool/to-from... ok]
     [testing Bool/from-to... ok]
     [testing Bool/valid... FAILED]
     Bool/valid:1.0 Error: False
     Bool/valid:2.0 Error: True

The style setting is made in qcheck.sml; other run-time configurable
settings are in settings.sml.  They use the SML/NJ Controls library,
but do not (yet) probe the runtime environment to initialize their
values.


Guide to tests directory
------------------------

The tests/ directory in the distribution contains some sample usages
of QCheck that are worth browsing.

 * compiler.sml demonstrates using external files for tests.  Files in
   tests/data/ have extension .acc if they should be accepted by the
   SML compiler, or .rej otherwise.  The test employs the "use"
   function and detects whether it raises an exception.

     ML compiler accepts....ok      (2 passed)          100% trivial
     ML compiler rejects....FAILED  (1/2 passed)        
           counter-examples:       tests/data/bug.rej

 * compose.sml: function composition is associative.  This
   demonstrates that generating random applicative functions (as
   outlined in the QuickCheck paper) is possible in SML.  Nifty, but
   not (IMO) terribly useful.

     compose associative....ok      (100 passed)        

 * from-to-str.sml: toString o fromString == identity?  Lots of Basis
   modules have fromString and toString functions that, "morally" at
   least should be inverses.  Are they?  The neat thing about this
   test is that it is parameterized in a functor, so the same check
   can apply (with adaptations) to all the Basis modules.

     Bool/to-from...........ok      (100 passed)        
     Bool/from-to...........ok      (100 passed)        
     Bool/valid.............FAILED  (4/10 passed)       
           counter-examples:       tRuE
                                   FaLsE
                                   TRUE
                                   FALSE
     Bool/invalid...........ok      (6 passed)          
     Char/to-from...........ok      (100 passed)        
     Char/from-to...........ok      (100 passed)        
     Char/valid.............ok      (4 passed)          
     Char/invalid...........ok      (5 passed)          
     String/to-from.........ok      (100 passed)        
     String/from-to.........dubious (5 passed)          
     String/valid...........ok      (3 passed)          
     String/invalid.........ok      (3 passed)          
     Date/to-from...........FAILED  (73/100 passed)     
           counter-examples:       Wed Nov  9 21:31:26 1994
                                   Tue Jun  6 22:35:01 2006
                                   Mon Dec  7 22:36:24 1981
                                   Thu Nov  2 05:32:10 1989
     Date/from-to...........ok      (100 passed)        
     Date/valid.............ok      (2 passed)          
     Date/invalid...........ok      (1 passed)          
     Int31/to-from..........ok      (100 passed)        
     Int31/from-to..........ok      (100 passed)        
     Int31/valid............ok      (5 passed)          
     Int31/invalid..........ok      (3 passed)          
     Int32/to-from..........ok      (100 passed)        
     Int32/from-to..........ok      (100 passed)        
     Int32/valid............ok      (5 passed)          
     Int32/invalid..........ok      (3 passed)          
     IntInf/to-from.........ok      (100 passed)        
     IntInf/from-to.........ok      (100 passed)        
     IntInf/valid...........ok      (5 passed)          
     IntInf/invalid.........ok      (3 passed)          

  The most significant bug found in this test suite is in
  Date.fromString.  All the counter-examples have single-digit days.
  Date.toString renders these dates by prepending an extra space, but
  Date.fromString will not parse it that way.  Date.fromString expects
  single-digit dates to be zero-padded instead:

     Date.fromString "Wed Jun  9 15:01:11 2004";
     val it = NONE : Date.date option
     Date.fromString "Wed Jun 9 15:01:11 2004";
     val it = NONE : Date.date option
     Date.fromString "Wed Jun 09 15:01:11 2004";
     val it = SOME (DATE ...) : Date.date option
     Date.toString(valOf it);
     val it = "Wed Jun  9 15:01:11 2004" : string

 * regex.sml demonstrates generation of recursive datatype, to test
   the regular expression compiler in the SML/NJ library.  It directly
   generates the AST and sends it to the compile method.  If it fails,
   it turns the AST back into a string to display the counter-example.
   I found several sources of failure in DfaEngine.compile this way.
   BacktrackEngine.compile is a no-op (it interprets the abstract
   synatx directly), so that test passed.

     DFA/compile............FAILED  (55/100 passed)     
           counter-examples:       ^v{2-5}*[^n]([^htw]??)
                                   v[^b](b|y{7-})+
                                   ^[dwz]$
                                   ^[^jo]|w?
     Backtrack/compile......ok      (100 passed)         77% size  1-4 nodes
                                                         16% size  5-8
                                                          7% size  9-16


 * reverse.sml: list-reversal properties; from QuickCheck paper.
   Fairly unremarkable.

     rev unit...............ok      (100 passed)        
     rev app................ok      (100 passed)         17% trivial
     rev rev................ok      (100 passed)          9% length 0
                                                         18% length 1-2
                                                         25% length 3-5
