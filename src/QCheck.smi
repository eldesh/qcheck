_require "basis.smi"
_require "APPLICATIVE_RNG.sml"
_require "BAG_SIG.sml"
_require "BagFromMap.smi"
_require "GEN_TYPES.sml"
_require "PREGEN_SIG.sml"
_require "SETTINGS_SIG.sml"
_require "Settings.smi"
_require "BaseGeneratorFn.smi"
_require "StringBag.smi"
_require "PROPERTY_SIG.sml"
_require "Property.smi"
_require "CMStyle.smi"
_require "QCheckVersion.smi"
(* generators *)
_require "INT_GENERATOR.sml"
_require "WORD_GENERATOR.sml"
_require "REAL_GENERATOR.sml"
_require "TEXT_GENERATOR.sml"
_require "DATE_TIME_GENERATOR.sml"
_require "FILES_SIG.sml"
_require "GENERATOR_SIG-smlsharp.sml"
_require "QCHECK_SIG.sml"
_require "PerlStyle.smi"
_require "RandGen-smlsharp.smi"
_require "Files.smi"

structure QCheck =
struct
  structure Gen = (* RandGen *)
  struct
    (* GEN_TYPES *)
    type rand = RandGen.rand
    type 'a gen = rand -> 'a * rand
    type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    (* PREGEN_SIG *)
    val new : unit -> rand
    val range : int * int -> rand -> int * rand
    type ('a,'b) reader = 'b -> ('a * 'b) option
    val lift : 'a -> 'a gen
    val select : 'a vector -> 'a gen
    val choose : 'a gen vector -> 'a gen
    val choose' : (int * 'a gen) vector -> 'a gen
    val selectL : 'a list -> 'a gen
    val chooseL : 'a gen list -> 'a gen
    val chooseL' : (int * 'a gen) list -> 'a gen
    val filter : ('a -> bool) -> 'a gen -> 'a gen
    val zip : ('a gen * 'b gen) -> ('a * 'b) gen
    val zip3 : ('a gen * 'b gen * 'c gen) ->
               ('a * 'b * 'c) gen
    val zip4 : ('a gen * 'b gen * 'c gen * 'd gen) ->
               ('a * 'b * 'c * 'd) gen
    val map : ('a -> 'b) -> 'a gen -> 'b gen
    val map2 : ('a * 'b -> 'c) -> ('a gen * 'b gen) ->
               'c gen
    val map3 : ('a * 'b * 'c -> 'd) ->
               ('a gen * 'b gen * 'c gen) -> 'd gen
    val map4 : ('a * 'b * 'c * 'd -> 'e) ->
               ('a gen * 'b gen * 'c gen * 'd gen) ->
               'e gen
    
    val flip : bool gen
    val flip' : int * int -> bool gen
    
    val list : bool gen -> 'a gen -> 'a list gen
    val option : bool gen -> 'a gen -> 'a option gen
    val vector : (int * (int -> 'a) -> 'b) ->
                 int gen * 'a gen -> 'b gen
    
    val variant : (int,'b) co
    val arrow : ('a, 'b) co * 'b gen -> ('a -> 'b) gen
    val cobool : (bool, 'b) co
    val colist : ('a, 'b) co -> ('a list, 'b) co
    val coopt : ('a, 'b) co -> ('a option, 'b) co
    
    type stream (= boxed)
    val start : rand -> stream
    val limit' : int -> 'a gen -> ('a,stream) reader
    val limit : 'a gen -> ('a,stream) reader
  
    (* TEXT_GENERATOR *)
    type char   = char
    type string = string
    type substring = substring
    val char : char gen
    val charRange : char * char -> char gen
    val charFrom : string -> char gen
    val charByType : (char -> bool) -> char gen
    val string : (int gen * char gen) -> string gen
    val substring : string gen -> substring gen
    val cochar : (char, 'b) co
    val costring : (string, 'b) co
    val cosubstring : (substring, 'b) co
  
    val stream : stream
    structure Int = (* INT_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
      
      type int = Int.int
      val int : int gen
      val pos : int gen
      val neg : int gen
      val nonpos : int gen
      val nonneg : int gen
      val coint : (int, 'b) co
    end
    structure Int32 = (* INT_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
      
      type int = Int32.int
      val int : int gen
      val pos : int gen
      val neg : int gen
      val nonpos : int gen
      val nonneg : int gen
      val coint : (int, 'b) co
    end
    structure IntInf = (* INT_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
      
      type int = IntInf.int
      val int : int gen
      val pos : int gen
      val neg : int gen
      val nonpos : int gen
      val nonneg : int gen
      val coint : (int, 'b) co
    end
    structure LargeInt = (* INT_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
  
      type int = LargeInt.int
      val int : int gen
      val pos : int gen
      val neg : int gen
      val nonpos : int gen
      val nonneg : int gen
      val coint : (int, 'b) co
    end
    structure Position = (* INT_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
      
      type int = Position.int
      val int : int gen
      val pos : int gen
      val neg : int gen
      val nonpos : int gen
      val nonneg : int gen
      val coint : (int, 'b) co
    end
  
    structure LargeReal = (* REAL_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type real = LargeReal.real
      val real : real gen
      val frac : real gen
      val pos : real gen
      val neg : real gen
      val nonpos : real gen
      val nonneg : real gen
      val finite : real gen
    end
    structure Real = (* REAL_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type real = Real.real
      val real : real gen
      val frac : real gen
      val pos : real gen
      val neg : real gen
      val nonpos : real gen
      val nonneg : real gen
      val finite : real gen
    end
    structure Real64 = (* REAL_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type real = Real64.real
      val real : real gen
      val frac : real gen
      val pos : real gen
      val neg : real gen
      val nonpos : real gen
      val nonneg : real gen
      val finite : real gen
    end
  
    structure LargeWord = (* WORD_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type word = LargeWord.word
      val word : word gen
      val coword : (word, 'b) co
    end
    structure Word = (* WORD_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type word = Word.word
      val word : word gen
      val coword : (word, 'b) co
    end
    structure Word8 = (* WORD_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type word = Word8.word
      val word : word gen
      val coword : (word, 'b) co
    end
    structure Word32 = (* WORD_GENERATOR *)
    struct
      type rand = rand
      type 'a gen = rand -> 'a * rand
      type ('a, 'b) co = 'a -> 'b gen -> 'b gen
    
      type word = Word32.word
      val word : word gen
      val coword : (word, 'b) co
    end

    structure DateTime =
    struct
      (* GEN_TYPES *)
      type rand = rand
      type 'a gen = 'a gen
      type ('a, 'b) co = ('a, 'b) co
      (* DATE_TIME_GENERATOR *)
      val weekday : Date.weekday gen
      val month : Date.month gen
      val dateFromYear : int gen -> Date.date gen
      val time : Time.time gen
      val dateFromUTC : Date.date gen
    end
  end

  structure Files = (* Files *)
  struct
    type ('a,'b) reader = 'b -> ('a * 'b) option
    type dirstream (= boxed)
    val openDir : string -> dirstream
    val nextFile : (string, dirstream) reader
  
    type filestream (= boxed)
    val openFile : string -> filestream
    val nextLine : (string, filestream) reader
  
    val map : ('a -> 'b) -> ('a,'c) reader -> ('b,'c) reader
    val filter : ('a -> bool) -> ('a,'b) reader -> ('a,'b) reader
    val chop : (string,'a) reader -> (string,'a) reader
  end

  structure Settings =
  struct
    type 'a control = 'a ref
	val get : 'a ref -> 'a
	val set : 'a ref * 'a -> unit
    val column_width : int ref
    val examples : int option ref
    val gen_max : int ref
    val gen_target : int option ref
    val outstream : TextIO.outstream ref
    val show_stats : bool ref
    val sort_examples : bool ref
  end

  (* include PROPERTY_SIG *)
  type 'a pred = 'a -> bool
  type 'a prop = 'a Property.prop
  val pred : 'a pred -> 'a prop
  val pred2 : ('a * 'b) pred -> 'b -> 'a  prop

  val implies : 'a pred * 'a prop -> 'a prop
  val ==> : 'a pred * 'a pred -> 'a prop

  val trivial : 'a pred -> 'a prop -> 'a prop
  val classify : 'a pred -> string -> 'a prop -> 'a prop
  val classify' : ('a -> string option) -> 'a prop ->
                'a prop

  type result = bool option
  type stats = { tags : StringBag.bag,
                 count : int }

  val test : 'a prop -> 'a * stats -> result * stats
  val stats : stats
  val success : result pred
  val failure : result pred

  type ('a,'b) reader = 'b -> ('a * 'b) option
  type 'a rep = ('a -> string) option
  val check : ('a,'b) reader * 'a rep ->
              string * 'a prop ->
              'b -> unit
  val checkGen : 'a Gen.gen * 'a rep ->
                 string * 'a prop -> unit
  val checkOne : 'a rep -> string * 'a prop -> 'a -> unit
  val checkGenShrink : ('a -> 'a list) -> 'a Gen.gen * 'a rep ->
                 string * 'a prop -> unit
  val cpsCheck : ('a -> 'a list) -> Property.stats -> ('a, 's) reader * 'a rep ->
                 'a prop ->
                 (string option * Property.result * Property.stats -> unit) ->
                 ('a list -> Property.stats -> 'b) -> 's -> 'b
  val version : int * int
  val context : string
end

