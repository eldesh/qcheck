<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator"
content="HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org" />
<title></title>
<meta name="generator" content="txt2html v1.28" />
</head>
<body>
<h1><a id="section-1." name="section-1.">QCheck/SML</a></h1>

<p>This is QCheck/SML, modeled after the QuickCheck automatic
testing library for Haskell by Koen Claessen and John Hughes
[ICFP&nbsp;2000, Haskell&nbsp;2002] (with many thanks). Nearly all
of the concepts come directly from their ICFP paper, but the
implementation is of course quite different. Like its cousin,
QCheck supports random generation of test data, but doesn&rsquo;t
emphasize that source over any other: indeed, the checker is
polymorphic over the type of test-case streams.</p>

<p>QCheck was developed for SML/NJ 110.45, and it uses parts of the
SML/NJ library. It should, however, be possible to adapt it to
other SML implementations (including older versions of NJ). I am
open to suggestions that would improve its portability or
usability.</p>

<p>The latest version of QCheck may be downloaded from
http://contrapunctus.net/dist/qcheck/</p>

<p>This library is free software; you may redistribute and/or
modify it under the terms of the GNU Lesser General Public License
(LGPL) as published by the Free Software Foundation; see the file
COPYING.</p>

<p>Copyright &copy;2004 Christopher League
&lt;league@contrapunctus.net&gt;</p>

<h2><a id="section-1.1." name="section-1.1.">Introduction</a></h2>

<p>I will demonstrate the use of QCheck with a simple example.
Let&rsquo;s write a few tiny functions on integers: successor,
even, and odd.</p>

<pre>
     fun succ x = x+1
     fun even x = x mod 2 = 0
     fun odd x = x mod 2 = 1
</pre>

<p>Now suppose we wish to test that some property holds for this
implementation. For example, we know that the successor of an even
number should be odd. We can specify &ldquo;the successor is
odd&rdquo; as the integer predicate &lsquo;odd o succ&rsquo;. But
since we expect this to be true only for even numbers, it is a
conditional property. Using the QCheck library, we specify it like
this:</p>

<pre>
     open QCheck infix ==&gt;
     val succ_even_odd = even ==&gt; odd o succ
</pre>

<p>This value has type &lsquo;int prop&rsquo;. To test it, we need
to specify a source of integer test cases. We could type a bunch of
them into a file and use that, but why not just generate them
randomly? &lsquo;Gen.Int.int&rsquo; (of type &lsquo;int
Gen.gen&rsquo;) generates random integers. The following pair is
useful for checking any integer property:</p>

<pre>
     val i = (Gen.Int.int, SOME Int.toString)
     checkGen i ("even+1=odd", succ_even_odd)
</pre>

<p>The &lsquo;toString&rsquo; function is provided so that the
checker can print out a counter-example if necessary. Next, we
simply called &lsquo;checkGen&rsquo; with a string tag and the
property. The type of &lsquo;checkGen&rsquo; is</p>

<pre>
     checkGen : 'a Gen.gen * ('a -&gt; string) option
                 -&gt; string * 'a prop -&gt; unit
</pre>

<p>&lsquo;checkGen&rsquo; is a specialization of a slightly more
general &lsquo;check&rsquo; routine, specifically tailored for
randomized data sources. The output of calling
&lsquo;checkGen&rsquo; above is:</p>

<pre>
     even+1=odd.............ok      (100 passed)        
     val it = () : unit
</pre>

<p>This indicates that 100 test cases were considered, and all
passed. (The target number of randomly-generated test cases is
configurable, as we&rsquo;ll see later.) Now, let&rsquo;s try the
converse property: the successor of an odd number is even.</p>

<pre>
     val succ_odd_even = odd ==&gt; even o succ
     checkGen i ("odd+1=even", succ_odd_even)
</pre>

<p>Simple, right? Well, this time we run into trouble. Here is the
output:</p>

<pre>
     odd+1=even.............FAILED  (99/100 passed)     
           counter-examples:       1073741823
</pre>

<p>QCheck found a counter-example: the maximum 31-bit integer. It
is odd, but since its successor is undefined, the property does not
hold. (We were not extraordinarily &lsquo;lucky&rsquo; to generate
maxInt this time around; in fact, the generator is biased so that
zero, minInt, and maxInt are chosen more frequently than other
integers, precisely because they are often &lsquo;boundary
conditions.&rsquo;)</p>

<p>At any rate, what is broken here is not really our even/odd/succ
implementation, but rather the specification of the property. We
need to limit it to odd integers that are less than maxInt.</p>

<pre>
     fun odd_not_max x = odd x andalso x &lt; valOf(Int.maxInt)
     val succ_odd_even = odd_not_max ==&gt; even o succ
     checkGen i ("odd+1=even", succ_odd_even)

     odd+1=even.............ok      (100 passed)        
</pre>

<p>Incidentally, the 100 cases to which this output refers are all
integers that meet the odd_not_max criterion. Generated integers
that do not meet the criterion are not counted. This is the meaning
of the ==&gt; (implies) operator, and is the reason that we
don&rsquo;t just combine the condition with the predicate into one
function.</p>

<p>Continuing with this example, suppose we want to test a property
of a pair of integers. For example, the sum of two odd numbers is
even.</p>

<pre>
     fun both_odd(x,y) = odd x andalso odd y
     fun sum_even(x,y) = even (x+y)
     fun show_pair(x,y) = Int.toString x ^ "," ^ Int.toString y
</pre>

<p>To generate pairs of ints, we just zip together two integer
generators. The function &lsquo;Gen.zip&rsquo; takes a t1 generator
and a t2 generator, and produces an (t1 * t2) generator.</p>

<pre>
     checkGen (Gen.zip(Gen.Int.int, Gen.Int.int), SOME show_pair)
              ("sum_odds_even", both_odd ==&gt; sum_even)

     sum_odds_even..........FAILED  (97/100 passed)     
           counter-examples:       897083003,850430501
                                   1073741823,298807
                                   ~845110003,~715751599
</pre>

<p>As you can see, QCheck found a few counter-examples (including
negative integers) that overflow the sum computation. I&rsquo;ll
leave it as an exercise to the reader to fix this.</p>

<p>One more example will demonstrate that test cases need not be
generated randomly. Here, they will be taken from a list, but they
could just as easily be read from a file.</p>

<pre>
     check (List.getItem, SOME show_pair)
           ("sum_odds_even[]", both_odd ==&gt; sum_even)
           [(1,1), (3,5), (3,4), (* that one won't count! *)
            (~1,1), (21,21), (7,13)]

     sum_odds_even[]........ok      (5 passed)          
</pre>

<p>I provided 6 pairs in the list, but only 5 counted because (3,4)
did not meet the precondition of the property.</p>

<h2><a id="section-1.2." name="section-1.2.">Reading test cases
from the file system</a></h2>

<pre>
     Once a human tester finds a bug, it should be the last time
     a human tester finds that bug. Automatic tests should check
     for it from then on.        -- Andrew Hunt and David Thomas
                                        The Pragmatic Programmer
</pre>

<p>Random testing is neat, and sometimes uncovers interesting cases
that you may not have tried. But to be sure you are covering
specific cases, you need to specify them somehow. The list example
at the end of the last section is one way, but another is reading
them from a file. QCheck provides a small API for using files
within a directory or lines within a text file as test cases.</p>

<p>The first parameter to &lsquo;check&rsquo; is a polymorphic
&lsquo;reader&rsquo;</p>

<pre>
     type ('a,'b) reader = 
           'b -&gt; ('a * 'b) option
</pre>

<p>where 'b is the type of a stream, and 'a is the type of a test
case. The &lsquo;FileSys&rsquo; structure provides readers and
utilities for directories and files:</p>

<pre>
     type dirstream
     val openDir : string -&gt; dirstream
     val nextFile : (string, dirstream) reader

     type filestream
     val openFile : string -&gt; filestream
     val nextLine : (string, filestream) reader

     val map : ('a -&gt; 'b) -&gt; ('a,'c) reader -&gt; ('b,'c) reader
     val filter : ('a -&gt; bool) -&gt; ('a,'b) reader -&gt; ('a,'b) reader
     val match : string -&gt; (string,'a) reader -&gt; (string,'a) reader
     val chop : (string,'a) reader -&gt; (string,'a) reader
</pre>

<p>The &lsquo;match&rsquo; function filters out filenames (or
lines) that match a particular regular expression. The
&lsquo;chop&rsquo; function removes the newline (if present) from
each line.</p>

<p>When writing a compiler, you may want to test that the parser
accepts a certain set of programs and rejects another set. Assuming
&lsquo;parseFile&rsquo; takes a string (the filename) and returns a
boolean, this is all you need:</p>

<pre>
     check (FileSys.match "\\.sml" FileSys.nextFile,
            SOME(fn s =&gt; s))
           ("accept", pred parseFile)
           (FileSys.openDir "tests/good")
</pre>

<p>and similarly for the directory "tests/bad", but with the
predicate (not o parseFile). The show function is identity, since
the test cases are already strings (representing filenames).</p>

<h2><a id="section-1.3." name="section-1.3.">Generating test cases
randomly</a></h2>

<p>The QuickCheck tool for Haskell uses type classes so that
arbitrary values of various types may be generated behind the
scenes. In SML, we need to be more explicit, but the same holds
true in Haskell if we don&rsquo;t want the default generator
(positive integers only, for example).</p>

<p>The &lsquo;Gen&rsquo; module holds a wide range of tools for
creating random values of various structured types and, yes, even
functions! We have already met &lsquo;Gen.zip&rsquo;, but some of
the other basic combinators are:</p>

<pre>
     val range : int * int -&gt; int gen  (* between x and y, inclusive *)
     val lift : 'a -&gt; 'a gen
     val select : 'a vector -&gt; 'a gen
     val choose : 'a gen vector -&gt; 'a gen
     val filter : ('a -&gt; bool) -&gt; 'a gen -&gt; 'a gen
     val map : ('a -&gt; 'b) -&gt; 'a gen -&gt; 'b gen
</pre>

<p>So, (lift 5) is a &lsquo;generator&rsquo; that always returns 5
&ndash; no randomness involved. &lsquo;choose&rsquo; selects and
invokes one of the generators in its argument vector (with equal
probability), so</p>

<pre>
     Gen.choose #[Gen.lift 42,
                  Gen.Int.int]
</pre>

<p>will return the number 42 with 50% probability, and a random
integer otherwise (but recall that Gen.Int.int is biased toward
zero and the extrema). &lsquo;select&rsquo; is like
&lsquo;choose&rsquo; combined with &lsquo;lift&rsquo;. Other
combinators exist for generating lists, vectors, and option types.
For example, the following generates a string with between 6 and 10
characters from the alphabet {a,b,c}:</p>

<pre>
     Gen.vector CharVector.tabulate
                (Gen.range(6,10), Gen.select #[#"a", #"b", #"c"])
</pre>

<p>where</p>

<pre>
     Gen.vector : (int * (int -&gt; 'a) -&gt; 'b) -&gt;
                  int gen * 'a gen -&gt; 'b gen
</pre>

<p>works on any data structure with a &lsquo;tabulate&rsquo;
constructor.</p>

<p>Here is a sample of some of the strings it generated in one
test:</p>

<pre>
     "abbacccbbb" : CharVector.vector
     "bccbaabacb" : CharVector.vector
     "aacbbbaba" : CharVector.vector
     "aabbaca" : CharVector.vector
     "acaacbb" : CharVector.vector
     "cbbbccab" : CharVector.vector
     "bbcaccca" : CharVector.vector
</pre>

<p>In addition to the general combinators, practically all of the
SML Basis types have associated generators in sub-structures.
We&rsquo;ve already met Gen.Int.int, but there is also:</p>

<pre>
     Gen.Int.int : int gen
     Gen.Int.pos : int gen     (* strictly positive *)
     Gen.Int.neg : int gen
     Gen.Int.nonpos : int gen
     Gen.Int.nonneg : int gen  (* zero or positive *)
</pre>

<p>And similarly for the other integer types:</p>

<pre>
     Gen.Int32.int : Int32.int gen
     Gen.IntInf.int : IntInf.int gen
</pre>

<p>And many others:</p>

<pre>
     Gen.Word.word : word gen
     Gen.Word8.word : Word8.word gen
     Gen.Word32.word : Word32.word gen
     Gen.Real.real : real gen
     Gen.DateTime.weekday : Date.weekday gen
     Gen.DateTime.dateFromYear : int gen -&gt; Date.date gen
</pre>

<p>Finally, the Text types &ndash; character, string, and
substring:</p>

<pre>
     Gen.char : char gen
     Gen.charRange : char * char -&gt; char gen
     Gen.charFrom : string -&gt; char gen
     Gen.charByType : (char -&gt; bool) -&gt; char gen
     Gen.string : (int gen * char gen) -&gt; string gen
     Gen.substring : string gen -&gt; substring gen
</pre>

<p>So the &lsquo;Gen.vector&rsquo; example above could be written
more concisely as:</p>

<pre>
     Gen.string (Gen.range(6,10), 
                 Gen.charFrom "abc")
</pre>

<p>Finally, all of the generators for basis types are implemented
as functors, so it would be trivial to produce generators for
Word16, Int64, or WideText, given an implementation of those
structures. Browse the file &lsquo;gen/gen.sig&rsquo; in the
distribution to discover more of the available generator
functionality.</p>

<p>As pointed out in the QuickCheck paper, one needs to be careful
when generating tree-structured data, due to the strong possibility
of non-termination. To avoid this problem, make the generator a
function of a decreasing integer parameter. When that parameter
reaches zero, the only choice is to return a leaf.</p>

<pre>
     datatype tree = Node of tree * tree | Leaf of int
     fun gentree 0 = Gen.map Leaf Gen.Int.int
       | gentree n = 
         Gen.choose' #[(1,Gen.map Leaf Gen.Int.int),
                       (4,Gen.map Node (Gen.zip(gentree(n div 2),
                                                gentree(n div 2))))]
</pre>

<h2><a id="section-1.4." name="section-1.4.">Statistical
distribution</a></h2>

<p>One problem with random test-case generation is thet we
don&rsquo;t know for sure what we&rsquo;re getting. QCheck provides
a way to observe the distribution of test cases by tagging them
based on user-definable criteria. For example, suppose we want to
test the &lsquo;ListMergeSort&rsquo; module in the SML/NJ library,
by generating random integer lists.</p>

<p>If we generate and pass 100 cases, what does that mean? Sorting
a list with fewer than 2 elements is pretty easy, so how many of
our 100 cases are that trivial? Also, how many of the lists are
already ordered?</p>

<p>fun fewer_than n L = length L &lt; n</p>

<pre>
     val sort_ok = ListMergeSort.sorted op&gt; o
                   ListMergeSort.sort op&gt;

     val sort_test = trivial (fewer_than 2)
                    (classify (ListMergeSort.sorted op&gt;) "pre-sorted"
                    (pred sort_ok))

     checkGen (Gen.list (Gen.flip'(1,9)) Gen.Int.int, NONE)
              ("ListMergeSort", sort_test)
</pre>

<p>Now the test result, if passing, will be accompanied with some
statistics on the distribution of the specified properties.</p>

<pre>
     ListMergeSort..........ok      (100 passed)         33% pre-sorted
                                                         28% trivial
</pre>

<p>The functions &lsquo;classify&rsquo; and &lsquo;trivial&rsquo;
are specializations of the more general &lsquo;classify'&rsquo;
(prime), with which we can provide a function that returns the tag.
To see the complete distribution of list lengths, try this:</p>

<pre>
     fun sizeTag n = 
         "length "^ StringCvt.padLeft #" " 3 (Int.toString n)

     val sort_test = classify' (SOME o sizeTag o length) (pred sort_ok)
     checkGen (Gen.list (Gen.flip'(1,9)) Gen.Int.int, NONE)
              ("ListMergeSort", sort_test)
</pre>

<pre>
     ListMergeSort..........ok      (100 passed)         13% length   0
                                                          7% length   1
                                                          6% length   2
                                                         13% length   3
                                                          8% length   4
                                                          6% length   5
                                                          3% length   6
                                                          2% length   7
                                                          5% length   8
                                                          5% length   9
                                                          2% length  10
                                                          5% length  11
                                                          3% length  12
</pre>

<p>The list goes on: the maximum length list generated in this run
was 43. The signatures of these and other property combinators are
in qcheck.sig.</p>

<h2><a id="section-1.5." name="section-1.5.">Pluggable output
styles</a></h2>

<p>The default output style is modeled after the unit-testing
framework for Perl. It makes room for statistics and
counter-examples, while leaving clear a column down the middle
where the "ok/FAILED" results can be easily read. The Perl style
uses the carriage return character \r to update the current line
with each test... this is a useful progress indicator for tests
that take a long time.</p>

<p>Output styles are completely configurable just by writing a
function of a particular type. An alternate style is provided,
which is meant to mesh well with the output of the SML/NJ
Compilation Manager (CM), like this:</p>

<pre>
     [testing Bool/to-from... ok]
     [testing Bool/from-to... ok]
     [testing Bool/valid... FAILED]
     Bool/valid:1.0 Error: False
     Bool/valid:2.0 Error: True
</pre>

<p>The style setting is made in qcheck.sml; other run-time
configurable settings are in settings.sml. They use the SML/NJ
Controls library, but do not (yet) probe the runtime environment to
initialize their values.</p>

<h2><a id="section-1.6." name="section-1.6.">Guide to tests
directory</a></h2>

<p>The tests/ directory in the distribution contains some sample
usages of QCheck that are worth browsing.</p>

<ul>
<li>compiler.sml demonstrates using external files for tests. Files
in tests/data/ have extension .acc if they should be accepted by
the SML compiler, or .rej otherwise. The test employs the
&lsquo;use&rsquo; function and detects whether it raises an
exception.</li>
</ul>

<pre>
     ML compiler accepts....ok      (2 passed)          100% trivial
     ML compiler rejects....FAILED  (1/2 passed)        
           counter-examples:       tests/data/bug.rej
</pre>

<ul>
<li>compose.sml: function composition is associative. This
demonstrates that generating random applicative functions (as
outlined in the QuickCheck paper) is possible in SML. Nifty, but
not (IMO) terribly useful.</li>
</ul>

<p>compose associative....ok (100 passed)</p>

<ul>
<li>from-to-str.sml: toString o fromString == identity? Lots of
Basis modules have fromString and toString functions that,
&lsquo;morally&rsquo; at least should be inverses. Are they? The
neat thing about this test is that it is parameterized in a
functor, so the same check can apply (with adaptations) to all the
Basis modules.</li>
</ul>

<pre>
     Bool/to-from...........ok      (100 passed)        
     Bool/from-to...........ok      (100 passed)        
     Bool/valid.............FAILED  (4/10 passed)       
           counter-examples:       tRuE
                                   FaLsE
                                   TRUE
                                   FALSE
     Bool/invalid...........ok      (6 passed)          
     Char/to-from...........ok      (100 passed)        
     Char/from-to...........ok      (100 passed)        
     Char/valid.............ok      (4 passed)          
     Char/invalid...........ok      (5 passed)          
     String/to-from.........ok      (100 passed)        
     String/from-to.........dubious (5 passed)          
     String/valid...........ok      (3 passed)          
     String/invalid.........ok      (3 passed)          
     Date/to-from...........FAILED  (73/100 passed)     
           counter-examples:       Wed Nov  9 21:31:26 1994
                                   Tue Jun  6 22:35:01 2006
                                   Mon Dec  7 22:36:24 1981
                                   Thu Nov  2 05:32:10 1989
     Date/from-to...........ok      (100 passed)        
     Date/valid.............ok      (2 passed)          
     Date/invalid...........ok      (1 passed)          
     Int31/to-from..........ok      (100 passed)        
     Int31/from-to..........ok      (100 passed)        
     Int31/valid............ok      (5 passed)          
     Int31/invalid..........ok      (3 passed)          
     Int32/to-from..........ok      (100 passed)        
     Int32/from-to..........ok      (100 passed)        
     Int32/valid............ok      (5 passed)          
     Int32/invalid..........ok      (3 passed)          
     IntInf/to-from.........ok      (100 passed)        
     IntInf/from-to.........ok      (100 passed)        
     IntInf/valid...........ok      (5 passed)          
     IntInf/invalid.........ok      (3 passed)          
</pre>

<p>The most significant bug found in this test suite is in
Date.fromString. All the counter-examples have single-digit days.
Date.toString renders these dates by prepending an extra space, but
Date.fromString will not parse it that way. Date.fromString expects
single-digit dates to be zero-padded instead:</p>

<pre>
     Date.fromString "Wed Jun  9 15:01:11 2004";
     val it = NONE : Date.date option
     Date.fromString "Wed Jun 9 15:01:11 2004";
     val it = NONE : Date.date option
     Date.fromString "Wed Jun 09 15:01:11 2004";
     val it = SOME (DATE ...) : Date.date option
</pre>

<ul>
<li>regex.sml demonstrates generation of recursive datatype, to
test the regular expression compiler in the SML/NJ library. It
directly generates the AST and sends it to the compile method. If
it fails, it turns the AST back into a string to display the
counter-example. I found several sources of failure in
DfaEngine.compile this way. BacktrackEngine.compile is a no-op (it
interprets the abstract synatx directly), so that test passed.</li>
</ul>

<pre>
     DFA/compile............FAILED  (55/100 passed)     
           counter-examples:       ^v{2-5}*[^n]([^htw]??)
                                   v[^b](b|y{7-})+
                                   ^[dwz]$
                                   ^[^jo]|w?
     Backtrack/compile......ok      (100 passed)         77% size  1-4 nodes
                                                         16% size  5-8
                                                          7% size  9-16
</pre>

<ul>
<li>reverse.sml: list-reversal properties; from QuickCheck paper.
Fairly unremarkable.</li>
</ul>

<pre>
     rev unit...............ok      (100 passed)        
     rev app................ok      (100 passed)         17% trivial
     rev rev................ok      (100 passed)          9% length 0
                                                         18% length 1-2
                                                         25% length 3-5
</pre>
</body>
</html>

