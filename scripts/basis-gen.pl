#! /usr/bin/perl
use strict;

my $impl = shift @ARGV;

my $sigFile = "src/GENERATOR_SIG-${impl}.sml";
my $genFile = "src/RandGen-${impl}.sml";
# for SML#
my $smiFile = "src/RandGen-${impl}.smi";
my $testFile = "tests/from-to-${impl}.sml";

open(SIG, ">$sigFile") or die 'cannot write sig';
open(GEN, ">$genFile") or die 'cannot write gen';
open(SMI, ">$smiFile") or die 'cannot write smi';
open(TEST, ">$testFile") or die 'cannot write test';

print SIG <<EOF;
(* DO NOT EDIT -- Generated by basis-gen.pl *)
signature GENERATOR_SIG = sig
  include TEXT_GENERATOR
  val stream : stream
  structure DateTime : DATE_TIME_GENERATOR
EOF

print GEN <<EOF;
(* DO NOT EDIT -- Generated by basis-gen.pl *)
functor GeneratorFn(R : APPLICATIVE_RNG) : GENERATOR_SIG =
struct
  local
    structure Gen = BaseGeneratorFn(R)
    structure Gen = GenText(structure Gen=Gen structure Text=Text)
  in 
EOF

print SMI <<EOF;
(* DO NOT EDIT -- Generated by basis-gen.pl *)
_require "basis.smi"
_require "APPLICATIVE_RNG.sml"
_require "BaseGeneratorFn.smi"
_require "GEN_TYPES.sml"
_require "PREGEN_SIG.sml"
(* generator signatures *)
_require "INT_GENERATOR.sml"
_require "WORD_GENERATOR.sml"
_require "REAL_GENERATOR.sml"
_require "PRETEXT_GENERATOR.sml"
_require "TEXT_GENERATOR.sml"
_require "DATE_TIME_GENERATOR.sml"
(* generator implements *)
_require "GenInt.smi"
_require "GenWord.smi"
_require "GenReal.smi"
_require "GenText.smi"
_require "GenDateTime.smi"
_require "GENERATOR_SIG-smlsharp.sml"
_require "Rand.smi"

structure RandGen = (* GeneratorFn(Rand) *)
struct
  (* GEN_TYPES *)
  type rand = Rand.rand
  type 'a gen = rand -> 'a * rand
  type ('a, 'b) co = 'a -> 'b gen -> 'b gen
  (* PREGEN_SIG *)
  val new : unit -> rand
  val range : int * int -> rand -> int * rand
  type ('a,'b) reader = 'b -> ('a * 'b) option
  val lift : 'a -> 'a gen
  val select : 'a vector -> 'a gen
  val choose : 'a gen vector -> 'a gen
  val choose' : (int * 'a gen) vector -> 'a gen
  val selectL : 'a list -> 'a gen
  val chooseL : 'a gen list -> 'a gen
  val chooseL' : (int * 'a gen) list -> 'a gen
  val filter : ('a -> bool) -> 'a gen -> 'a gen
  val zip : ('a gen * 'b gen) -> ('a * 'b) gen
  val zip3 : ('a gen * 'b gen * 'c gen) ->
             ('a * 'b * 'c) gen
  val zip4 : ('a gen * 'b gen * 'c gen * 'd gen) ->
             ('a * 'b * 'c * 'd) gen
  val map : ('a -> 'b) -> 'a gen -> 'b gen
  val map2 : ('a * 'b -> 'c) -> ('a gen * 'b gen) ->
             'c gen
  val map3 : ('a * 'b * 'c -> 'd) ->
             ('a gen * 'b gen * 'c gen) -> 'd gen
  val map4 : ('a * 'b * 'c * 'd -> 'e) ->
             ('a gen * 'b gen * 'c gen * 'd gen) ->
             'e gen

  val flip : bool gen
  val flip' : int * int -> bool gen

  val list : bool gen -> 'a gen -> 'a list gen
  val option : bool gen -> 'a gen -> 'a option gen
  val vector : (int * (int -> 'a) -> 'b) ->
               int gen * 'a gen -> 'b gen

  val variant : (int,'b) co
  val variant' : (int * int,'b) co
  val arrow : ('a, 'b) co * 'b gen -> ('a -> 'b) gen
  val cobool : (bool, 'b) co
  val colist : ('a, 'b) co -> ('a list, 'b) co
  val coopt : ('a, 'b) co -> ('a option, 'b) co

  type stream (= *)
  val start : rand -> stream
  val limit' : int -> 'a gen -> ('a,stream) reader
  val limit : 'a gen -> ('a,stream) reader

  (* TEXT_GENERATOR *)
  type char   = char
  type string = string
  type substring = substring
  val char : char gen
  val charRange : char * char -> char gen
  val charFrom : string -> char gen
  val charByType : (char -> bool) -> char gen
  val string : (int gen * char gen) -> string gen
  val substring : string gen -> substring gen
  val cochar : (char, 'b) co
  val costring : (string, 'b) co
  val cosubstring : (substring, 'b) co

  val stream : stream
EOF

foreach my $mod (<STDIN>)
{
    chomp($mod);
    if($mod =~ /Int|Position/)
    {
        print SIG "structure $mod : INT_GENERATOR\n";
        print GEN "structure $mod = GenInt(open Gen structure Int = $mod)\n";
		print SMI <<EOF;
  structure $mod = (* INT_GENERATOR *)
  struct
    type rand = rand
    type 'a gen = rand -> 'a * rand
    type ('a, 'b) co = 'a -> 'b gen -> 'b gen

    type int = $mod.int
    val int : int gen
    val pos : int gen
    val neg : int gen
    val nonpos : int gen
    val nonneg : int gen
    val coint : (int, 'b) co
  end
EOF
        print TEST "structure I = IntFromTo($mod)\n";
        print TEST "structure T = TestFromToString(open I val name=\"$mod\")\n";
    }
    elsif($mod =~ /Word/)
    {
        print SIG "structure $mod : WORD_GENERATOR\n";
        print GEN "structure $mod = GenWord(open Gen structure Word = $mod)\n";
		print SMI <<EOF;
  structure $mod = (* WORD_GENERATOR *)
  struct
    type rand = rand
    type 'a gen = rand -> 'a * rand
    type ('a, 'b) co = 'a -> 'b gen -> 'b gen

    type word = $mod.word
    val word : word gen
    val coword : (word, 'b) co
  end
EOF
    }
    elsif($mod =~ /Real/)
    {
        print SIG "structure $mod : REAL_GENERATOR\n";
        print GEN "structure $mod = GenReal(open Gen structure Real = $mod)\n";
		print SMI <<EOF;
  structure $mod = (* REAL_GENERATOR *)
  struct
    type rand = rand
    type 'a gen = rand -> 'a * rand
    type ('a, 'b) co = 'a -> 'b gen -> 'b gen

    type real = $mod.real
    val real : real gen
    val frac : real gen
    val pos : real gen
    val neg : real gen
    val nonpos : real gen
    val nonneg : real gen
    val finite : real gen
  end
EOF
    }
    elsif($mod =~ /Text/)
    {
        print SIG "structure $mod : PRETEXT_GENERATOR\n";
        print GEN "structure $mod = GenText(structure Gen=Gen structure Text=$mod)\n";
    }
    else
    {
        print "Skipping unrecognized module: $mod\n";
    }
}

print SIG "end\n";

print GEN <<EOF;
    structure DateTime = GenDateTime(Gen)
    open Gen
    val stream = start (R.new())
  end (* local *)
  type rand = R.rand
  type 'a gen = rand -> 'a * rand
  type ('a, 'b) co = 'a -> 'b gen -> 'b gen
end
structure RandGen = GeneratorFn(Rand)
EOF

print SMI <<EOF;
  structure DateTime =
  struct
    (* GEN_TYPES *)
    type rand = rand
    type 'a gen = 'a gen
    type ('a, 'b) co = ('a, 'b) co
    (* DATE_TIME_GENERATOR *)
    val weekday : Date.weekday gen
    val month : Date.month gen
    val dateFromYear : int gen -> Date.date gen
    val time : Time.time gen
    val dateFromUTC : Date.date gen
  end
end
EOF

close(SIG);
close(GEN);
close(SMI);
close(TEST);
exit;
